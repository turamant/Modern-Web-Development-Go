<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Page 5</title>
    <link href="static/css/main.css" rel="stylesheet">
</head>
<body>
    <h1>Проектирование веб-приложений.</h1>
    <h2>Введение</h2>
    <p>В этой главе мы познакомимся с концепцией
        жизненного цикла разработки программного обеспечения (SDLC) и изучим основные концепции проектирования приложений. Мы
        научимся разделять и организовывать наши кодовые решения. Сначала мы упомянем
        пару распространенных шаблонов проектирования приложений и предоставим основные сведения
        о каждом из них. После этого мы углубимся в многоуровневый
        шаблон проектирования и увидим обязанности каждого отдельного уровня. В конце главы
        мы спланируем и спроектируем наше веб-серверное приложение.</p>

    <h2>Жизненный цикл разработки программного обеспечения (SDLC).</h2>
    <p>Жизненный цикл разработки программного обеспечения часто определяют как структуру,
        определяющую задачи, выполняемые на каждом этапе процесса разработки программного обеспечения.
        Обычно в рамках SDLC присутствуют пять этапов:</p>
    <ul>
        <li>Планирование</li>
        <li>Проектирование</li>
        <li>Разработка</li>
        <li>Тестирование</li>
        <li>Сопровождение</li>
    </ul>
   <p>Фазы определяются следующим образом:</p>
   <ul>
    <li>На этапе планирования должны быть
        определены все бизнес-требования. Идея состоит в том, чтобы определить, какую услугу наше программное решение должно
        предоставлять будущим пользователям.
        На основе этих требований следует определить основные варианты использования . Окончательное решение должно правильно реализовать все
        определенные варианты использования, чтобы его можно было выпустить и использовать.</li>
        <p>
            На этапе планирования может быть создан общий проект плана того, как и в течение какого времени должно быть завершено создание программного решения. Также все потенциальные
            риски должны быть выявлены при планировании, чтобы избежать будущих проблем
            и задержек с выпуском готового продукта.
        </p>
    <li>Конечным продуктом этапа проектирования должен быть общий план
        программного решения. Этот план может включать в себя:
    <ul>
        <li>Проект базы данных, которая будет использоваться, с определенными таблицами и
            отношениями.</li>
        <li>Процессы и протоколы безопасности (кто и как может получить доступ к определенным
            данным).</li>
        <li>Стек технологий, который будет использоваться на
            этапе разработки (языки программирования, базы данных и т. д.).</li>
        <li>Разработка API и потенциальная интеграция с другими программными решениями.</li>
        <li>Компоненты, входящие в состав решения</li>
        <li>Проектирование алгоритма и архитектуры (при необходимости).</li>
    </ul></li>
    <li>Общий план, созданный на этапе проектирования, следует использовать
        на этапе разработки для разработки решения. Создаваемое
        решение должно отвечать бизнес-запросам, определенным на этапе планирования
        .</li>
    <li>На этапе тестирования разработанное программное обеспечение будет проверено на соответствие
        сценариям использования, определенным на этапах планирования. Чтобы программное решение получило
        зеленый свет для публичного выпуска, оно должно пройти все тесты. Если некоторые
        тесты не пройдены, программное обеспечение необходимо исправить и протестировать еще раз.</li>
    <li>После успешного завершения всех предыдущих этапов
        можно выпустить программное решение и начать заключительную фазу обслуживания. На
        этом этапе выпущенное решение отслеживается, чтобы проверить, все ли
        работает правильно. Если некоторые пользователи сообщают о каких-либо нарушениях или проблемах, это
        следует изучить и исправить, если проблема связана с
        выпущенным решением. Эта фаза активна до тех пор, пока программное обеспечение живо.</li>
   </ul>

   <p>Мы можем включить новые функции в выпущенное программное решение. Он также должен
    пройти все этапы жизненного цикла разработки программного обеспечения.
    Современный процесс разработки приложений не так прост, как
    описано здесь. Все этапы по-прежнему присутствуют, но они часто переплетаются,
    имея обратную связь с предыдущим этапом. Этот подход известен как гибкая
    методология.</p>
    <p>Чтобы внести максимальную ясность, в этой и последующих главах мы
        будем следовать процессу, описанному в этом разделе, и пройдем
        весь процесс разработки программного обеспечения.</p>
    
    <h2>Общие подходы к проектированию приложений</h2>
    <p>По общему определению дизайн можно определить как план или спецификацию строительства
        определенного объекта. В нашем случае объектом является наше веб-серверное
        приложение. Хороший проект программного обеспечения должен включать в себя большинство аспектов, перечисленных в
        предыдущем разделе (проектирование базы данных, технологический стек и т. д.).</p>
    <p>Хорошей практикой является уделять больше времени фактическому проектированию и постараться охватить
        большинство известных вопросов. Начало разработки с плохим дизайном может вызвать массу
        проблем и задержки выпуска приложения. Отказ от
        проекта, когда разработка уже начата, требует перепроектирования решения
        и отказа от всего, что уже было сделано.</p>
    <p>Есть и другой подход к этой проблеме. Мы можем выпустить приложение в
        его текущем состоянии и перепроектировать его на лету. Но здесь мы должны пожертвовать временем
        , которое можно использовать для разработки новых функций, поскольку время необходимо
        потратить на редизайн и рефакторинг кода.</p>
    <p>В разработке мы часто решаем подобные задачи. Некоторые общие схемы
        разработаны и могут использоваться для решения конкретных задач. Эти повторно используемые конструкции
        известны как шаблоны проектирования.</p>
    <ul>Следующие шаблоны проектирования являются одними из наиболее популярных:
        <li>Шаблон многоуровневого проектирования. </li>
        <li>Шаблон проектирования микроядра (подключаемого модуля).</li>
        <li>Шаблон проектирования.
            Разделение ответственности за команды и запросы (CQRS).</li>
        <li>Шаблон проектирования.
            Комбинированный (гибридный) шаблон проектирования.</li>
    </ul>
    <p>Шаблон многоуровневого проектирования будет подробно рассмотрен в отдельном разделе,
        поскольку мы будем использовать его для проектирования и разработки нашего веб-серверного приложения.
        Другие шаблоны будут рассмотрены в этом разделе с меньшим количеством деталей.</p>
    <p>Для каждого из них мы увидим основные идеи, примеры использования, а также некоторые
        преимущества и недостатки.</p>

    <h3>Шаблон проектирования микроядра (плагина)</h3>
    <ul>В этом шаблоне проектирования у нас есть два компонента
        <li>Микроядро (основной набор обязанностей)</li>
        <li>Плагины (взаимозаменяемые части)</li>
    </ul>
    <p>Микроядро является точкой входа в приложение и обеспечивает общий поток работы.
        Плагин будет выполнять конкретную задачу. Интересно то, что микроядро не знает роли отдельного плагина, но каждый плагин
        должен следовать дизайну API, определенному микроядром. Другими словами,
        плагин должен быть совместим с микроядром, чтобы иметь возможность
        с ним соединиться:</p>
    <p>Хорошим примером применения этого шаблона проектирования является простой
        планировщик задач. Микроядро будет обеспечивать логику планирования, а плагины будут
        выполнять конкретные задачи. Планировщику не нужно знать подробности об
        отдельных задачах, ему просто нужно их запланировать.</p>
    <p>Этот подход имеет много преимуществ. Одним из основных является то, что новые
        плагины можно добавлять к работающему приложению без каких-либо видимых
        перерывов. Этот шаблон проектирования обеспечивает высокую гибкость и расширяемость,
        можно добавлять любые виды плагинов, если они соответствуют спецификациям API,
        объявленным микроядром.</p>
    <p>Микроядро и все отдельные плагины могут разрабатываться отдельными командами.
        (которые не обязательно должны находиться в одних и тех же физических местах). Это может
        существенно ускорить разработку приложений, поскольку разработку
        отдельных компонентов можно распараллелить.</p>
    <p>Очевидно, что этот подход имеет множество недостатков. Предопределенный API микроядра
        может быть уместным на момент первоначальной разработки приложения, но может
        оказаться неоптимальным для будущих плагинов. Кроме того, иногда бывает сложно разделить, за что
        должно отвечать микроядро, а за что —
        плагины.</p>
    <p>Всякий раз, когда у нас есть несколько компонентов, обеспечивающих определенную функциональность,
        интеграционное тестирование (когда несколько компонентов тестируются как группа) может быть
        сложным. Здесь может быть огромное количество различных плагинов, поэтому
        необходимо охватить несколько сценариев тестирования.</p>
    <p>Шаблон проектирования микроядра идеально подходит для приложений, обрабатывающих данные из
        разных источников, где отдельный плагин может обрабатывать один источник. Как мы
        уже упоминали, приложения для планирования задач идеально подходят для использования
        этого подхода.</p>

    <h3>Command and Query Responsibility Segregation
        (CQRS) design pattern.............................</h3>
        










</body>
</html>