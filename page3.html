<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Page 3</title>
    <link href="static/css/main.css" rel="stylesheet">
</head>
<body>
    <h1>Глава 3 Веб-серверы</h1>
<h2>Введение</h2>
<p>В этой главе будут рассмотрены основы веб-серверов, которые послужат хорошей основой
    для приложения, которое мы планируем разработать в следующих главах. Мы
    представим концепцию серверов, уделив особое внимание веб-серверам. После
    этого мы углубимся в архитектуру REST и протоколы HTTP. В
    конце главы мы объясним JSON и маршрутизацию.</p>
<h2>Структура</h2>
<ul>В этой главе мы обсудим следующие темы:
    <li>Серверы</li>
    <li>Веб-серверы</li>
    <li>Прокси</li>
    <li>REST</li>
    <li>HTTP
        <li>Поток HTTP</li>
        <li>HTTP-сообщения</li>
        <li>Методы HTTP</li>
        <li>Дополнительные функции</li>
        <li>HTTP и REST</li>
    <li>JSON
        <li>JSON и Go</li>
    <li>Routing</li>
</ul>
<h2>СЕРВЕРЫ</h2>
<p><span>Сервер</span> можно определить как программное или аппаратное обеспечение, обеспечивающее определенные
    функции для других программ или устройств (клиентов). Поскольку у нас есть две
    стороны в общении (клиенты и серверы), эта модель общения называется
    моделью <span>клиент-сервер</span>.
</p>    
<p>Клиент обычно отвечает за взаимодействие с пользователем, а
    сервер будет хранить и обрабатывать данные. Типичный процесс
    взаимодействия клиент-сервер можно описать двумя этапами:</p>
<ul>
    <li>Клиент отправляет сообщение (часто называемое запросом) на сервер.</li>
    <li>Сервер получит это сообщение, обработает его и вернет сообщение
        (часто называемое ответом) клиенту.</li>
</ul>   
<p>Клиент и сервер подключены к какой-либо сети (интернет или
    локальный, внутренний, сетевой). Один сервер может обслуживать несколько клиентов, а один
    клиент может использовать несколько серверов. На рис. 3.1 мы можем видеть графическое
    представление модели клиент-сервер.</p>
<p>Мы можем классифицировать серверы по назначению. Вот некоторые из наиболее распространенных
    серверов:</p> 
<ul>
    <li>Серверы баз данных: обеспечивают обслуживание базы данных, поддерживают и совместно используют любую
        форму базы данных.</li>
    <li>Серверы приложений: Хост-приложение. Клиенты могут запускать приложения
        и получать доступ к ресурсам приложений через сервер приложений.</li>
    <li>Файловые серверы: обеспечивают общее хранилище, в котором файлы и каталоги могут
        храниться и совместно использоваться клиентами.</li>
    <li>Почтовые серверы: предоставляют услуги для связи по электронной почте.</li>
    <li>Игровые серверы: размещение многопользовательских игр. Несколько клиентов (ПК
        , мобильные телефоны или игровые приставки) могут одновременно
        играть в игру.</li>
    <li>Медиа-серверы: делитесь цифровым видео- и аудиоконтентом с помощью
        потоковой передачи мультимедиа.</li>
    <li>Веб-серверы: размещают веб-приложения (веб-сайты или веб-порталы).</li>
</ul>
<p><img src="static/images/pic3.1.png"/></p>
<p class="figure">Рисунок 3.1: Модель клиент-сервер</p>    
    
<p>Некоторые категории пересекаются, игры и веб-приложения — это только приложения определенного
    типа, поэтому игровые серверы и веб-серверы — это просто особый тип
    серверов приложений. Но эти серверы слишком распространены, поэтому их вынесли в
    отдельную категорию.
    Что нас больше всего интересует, так это веб-серверы, потому что мы будем иметь дело с
    ними в этой книге. Теперь мы более подробно рассмотрим веб-серверы.</p>
<h2>Веб-серверы</h2>
<p>Веб-серверы являются одним из наиболее распространенных серверов, используемых для размещения веб-
    приложений. Они предоставляют все необходимые данные клиентам (в основном, веб-
    браузерам), чтобы клиенты могли отображать контент (веб-сайт или веб-платформу, мы
    можем использовать собирательный термин — документы).</p>
<p>Следующие шаги представляют собой типичный цикл обработки для веб-клиентов и
    серверов:</p>

<ol>
    <li>Клиент запрашивает HTML-страницу, и сервер возвращает
        HTML-страницу. HTML (язык гипертекстовой разметки) — это язык
        документов, предназначенный для отображения в веб-браузере.</li>
    <li>Клиент запросит таблицу стилей, а сервер вернет
        файл CSS. CSS расшифровывается как каскадные таблицы стилей, язык, используемый для определения
        внешний вид веб-страницы.</li>
    <li>Клиент запрашивает дополнительные ресурсы (изображения, видео, аудио, сценарии
        и т. д.), а сервер возвращает соответствующие файлы или ссылки на эти файлы.</li>
    <li>Клиент будет запрашивать данные, а сервер будет получать данные из
        базы данных и отправлять их клиенту (обычно в формате JSON, который будет
        подробно описан позже).</li>
    <li>Клиент объединит полученные данные для создания и отображения
        документа.</li>
</ol>    
 <p>Как мы видим, часть шагов могут выполнять серверы из других
    категорий. Например, сервер приложений может возвращать данные из
    базы данных, или файловый сервер может обслуживать изображения. С точки зрения клиента
    веб-сервер может выглядеть как единое целое, но на практике; веб-сервер представляет собой
    комбинацию нескольких разных серверов (рис. 3.2).</p>
 <p>Между клиентами и серверами мы можем поставить специальные серверы, называемые прокси. Они
    могут выполнять определенные задачи и обогащать сообщения. Подробнее о них мы поговорим
    в следующем разделе.</p>   
<p><img src="static/images/pic3.2.png"/></p>
<p class="figure">Рисунок 3.2: Веб-сервер как комбинация нескольких серверов</p>    
<p>Современные веб-серверы используют протокол HTTP для связи и
    обмена данными, поэтому мы также более подробно рассмотрим эту тему.
    Часть веб-сервера, которая нас интересует и которая будет
    разработана в этой книге, — это часть, которая считывает и сохраняет данные в базе данных (Шаг 4
    в цикле веб-клиент-сервер). В следующих главах мы узнаем, как
    получать и обрабатывать запросы от клиента и отправлять правильный ответ</p>    
<h2>Прокси</h2>    
<p>Прокси можно определить как машину, которую можно разместить между клиентом и сервером.</p>
<ul>Существует два типа прокси:
    <li>Прозрачный прокси просто пересылает сообщение без каких-либо
        изменений.</li>
    <li>Непрозрачный прокси модифицирует сообщение перед его передачей./li>
</ul> 
<p>Несколько действий могут быть выполнены с прокси. Вот некоторые из наиболее распространенных:</p>
<ul>
    <li>Кэширование: сообщения, относящиеся к определенному ресурсу, будут храниться на
        прокси-сервере. В следующий раз, когда этот ресурс потребуется, прокси ответит
        кэшированным значением вместо сервера. Это предотвратит многократное
        чтение идентичных баз данных на стороне сервера. Операции с базой данных
        обычно выполняются очень медленно, поэтому это повысит производительность всего
        система.</li>
    <li>Фильтрация: на сервер
        будут пересылаться только сообщения, отвечающие определенным критериям .
        Например, сервер будет принимать сообщения только из
        определенной географической области, а все остальные сообщения будут отклонены.
    </li>
    <li>Балансировка нагрузки: когда представлено несколько экземпляров одних и тех же серверов
        , прокси-сервер попытается переслать сообщение наименее
        занятому экземпляру.</li>
    <li>Аутентификация:
        на сервер будут пересылаться только сообщения от клиентов с соответствующими разрешениями.
    </li>
    <li>Ведение журнала: информация о сообщениях будет храниться для
        восстановления связи в случае возникновения ошибок или проблем.    
    </li>
</ul> 


<h2>REST</h2>
<p>REST (Representational State Transfer) — это архитектурный стиль программного обеспечения, используемый для описания интерфейса между различными компонентами, часто разделенными по сети. Он был разработан Роем Филдингом в 2000 году. Ресурс можно охарактеризовать как абстракцию информации в REST. Любая информация, которую мы можем идентифицировать и назвать, может считаться ресурсом (документы, изображения, услуги и т. д.). Каждый ресурс определяется его состоянием, известным как представление ресурса. Представление ресурса состоит из следующих частей:</p>
      <ul>
        <li>Данные</li>
        <li>Метаданные — это дополнительная информация, описывающая данные. Метаданные
            могут использоваться для управления кэшированием, обнаружения ошибок передачи, согласования
            соответствующий формат представления или выполнить аутентификацию.</li>
        <li>Гипермедийные ссылки, которые можно использовать при переходе к следующему желаемому состоянию.</li>
      </ul>  
<p>Гипермедиа можно описать как концепцию, в которой сервер будет информировать клиента
    о запросах, которые клиент может выполнить в будущем. Например,
    сервер отправит HTML-страницу, на которой
    будут доступны дополнительные операции, связанные с ресурсом, например кнопка, которая удалит ресурс.
    Когда пользователь нажимает эту кнопку, будет инициирован запрос к серверу, и
    фактическое представление ресурса будет удалено.
    Итак, подведем итог: сервер предоставит варианты, но клиент сам выберет,
    какой вариант ему нужен.
    Интерфейс службы должен удовлетворять шести руководящим принципам REST и
    ограничениям. Служба, отвечающая этому критерию, называется службой RESTful.</p>
    <ul>Вот шесть руководящих принципов REST:
        <li>1. Единый интерфейс. Чтобы заархивировать это, мы должны учесть несколько
            моментов:
            Идентификация ресурсов: Отдельные ресурсы, используемые во
            взаимодействии между клиентом и сервером, должны быть однозначно идентифицированы.
            Манипулирование ресурсами. Отдельные ресурсы должны иметь
            уникальное единообразное представление на стороне сервера. Интерфейс
            должен использовать это представление для изменения состояния ресурса на
            сервере.
            Самоописательные сообщения: каждое сообщение должно нести достаточно информации.
            информацию, описывающую, как ее следует обрабатывать. Он может
            дополнительно предоставлять информацию о действиях, которые клиент может
            выполнять с этим ресурсом.
            Гипермедиа как двигатель приложения: клиент
            должен использовать только начальный URL-адрес приложения. Клиент
            должен динамически использовать ссылки, предоставляемые сервером, для обнаружения и
            доступа ко всем доступным ресурсам</li>
        <li>2. Клиент – Сервер. Проблемы между клиентом и
            сервером должны быть разделены. Клиент обрабатывает взаимодействие с пользователем, а сервер занимается хранением и манипулированием данными. Клиент — это тот, кто инициирует
            общение и диктует, что будет делать с ресурсами.
            Интерфейс должен быть переносимым на разные платформы, чтобы разные
            типы клиентов (веб-браузеры, мобильные телефоны и т. д.) могут использовать один
            и тот же сервер. Клиент и сервер со временем будут развиваться, поэтому мы должны быть
            осторожны, чтобы не сломать интерфейс.</li>
        <li>3. Без сохранения состояния: каждый запрос от клиента должен содержать всю необходимую
            информацию, которую клиент может использовать для понимания и обработки
            запроса. Сервер не может использовать информацию, предоставленную в любом
            предыдущем запросе, для выполнения текущего запроса.</li>
        <li>4. Кэшируемое. Сообщения, которые клиент получает от сервера, могут быть
            помечены как кэшируемые или некэшируемые. Если сообщение кэшируется,
            клиент может хранить его локально и повторно использовать данные для будущих эквивалентных запросов.
            Данные должны храниться в течение определенного периода времени и после этого удаляться.
            Каждое повторное использование может продлить этот период.</li>
        <li>5. Многоуровневая система. Архитектура будет состоять из иерархических слоев,
            каждый из которых будет ограничивать определенное поведение. Каждый компонент
            не видит дальше непосредственного уровня, с которым он взаимодействует.</li>
        <li>6. Код по требованию (необязательно). Клиент может расширить свою функциональность
            , загрузив и выполнив код с сервера, обычно в виде
            скриптов. Это может значительно упростить клиент: необходимо реализовать лишь небольшое количество функций, а все дополнительные функции
            будет предоставлять сервер .</li>
    </ul>
    <p>Методы REST используются для выполнения желаемого перехода между состояниями
        любого ресурса, при этом доступ к ресурсам осуществляется через унифицированные
        идентификаторы ресурсов (URI).</p>    
<h2>HTTP</h2>
<p>HTTP (протокол передачи гипертекста) был разработан в начале девяностых годов
    и представляет собой основу для любого обмена данными в сети. Он
    представляет собой протокол клиент-сервер, где связь инициируется получателем
    (клиентом, обычно веб-браузером).</p>
    <ul>У этого протокола есть два основных преимущества:
        <li>он прост и удобен для чтения человеком (что мы увидим в
            примерах сообщений далее в этой главе). Мы очень легко поймем, о чем
            идет речь, просто проанализировав содержание сообщения.</li>
        <li>HTTP очень расширяем. Мы можем ввести новую функциональность,
            добавив новый пользовательский заголовок или изменив семантику. Клиент и
            сервер должны знать об этих изменениях. Правило того, как клиент и
            сервер будет общаться, часто называют соглашением.</li>
    </ul>
    <p>По умолчанию HTTP не сохраняет состояние, между двумя успешными запросами, выполненными через одно и то же соединение, нет связей
        (контекст не будет использоваться совместно
        между запросами). Но мы можем использовать файлы cookie (небольшие блоки данных, созданные сервером
        и размещенные на клиенте) для создания сеанса с сохранением состояния. Теперь контекст
        может распределяться между запросами. </p>
    <p>Контекст можно определить как локальное хранилище, в котором могут храниться
        данные, относящиеся к текущему запросу (идентификатор пользователя, данные, связанные с аутентификацией, и т. д.).
        Контекст
        будет удален после завершения связи, но мы видели,
        что его можно запечатать и повторно использовать в дальнейших запросах.</p> 
<h3>Поток HTTP</h3>  
<ul>Когда клиент хочет связаться с сервером, будут выполнены
    следующие четыре шага: 
    <li>1. TCP-соединение будет открыто и использовано для отправки и получения сообщений. Клиент может открыть новое соединение или повторно использовать существующее . </li>
    <li>2. Клиент отправит сообщение на сервер.</li>
    <li>3. Клиент прочитает сообщение, полученное от сервера. </li>
    <li>4. TCP-соединение будет закрыто или повторно использовано для дальнейшего обмена данными.</li>
    <p>TCP означает протокол управления передачей, один из основных протоколов обмена сообщениями по сети.</p>
</ul> 
<h3>HTTP-сообщения</h3>
<ul>Существует два типа HTTP-сообщений:
    <li>HTTP-запрос: сообщение, отправленное клиентом.</li>
    <li>HTTP-ответ: сообщение, отправленное сервером.</li>
</ul>
<ul>HTTP-запрос состоит из следующих элементов:
    <li>Метод, определяющий операцию, которую клиент хочет выполнить с
        ресурсом.</li>
    <li>Путь — это, по сути, URL-адрес без элементов, очевидных из
        контекста, таких как протокол, домен или порт (URL: http://nationallibrary.org:8080/book/275, путь: book/275).</li>
    <li>Версия протокола HTTP.</li>
    <li>Заголовки, которые предоставляют серверам дополнительную информацию (
        разрешения на авторизацию, формат данных, предоставляемых в теле запроса и т. д.).</li>
    <li>Тело (необязательно), содержащее ресурс, отправленный клиентом.</li>
</ul>
<p>Вот упрощенный пример одного HTTP-запроса (без тела), который можно
    использовать для получения информации о книге с сервера:</p>
    <table>
        <thead>
            <tr>
              <th>Method: POST</th>
              <th>Path: /book/275</th>
              <th>Version: HTTP/1.1</th>
            </tr>
        </thead>
        <tbody>
            <tr>
              <td>Headers:</td>
            </tr>
            <tr>
                <td>Content-Type: application/json</td>
            </tr>
            <tr>
                <td>Accept-Language: en-US,en;q=0.5</td>
            </tr>
            <tr>
                <td>Accept-Encoding: gzip</td>
            </tr>
        </tbody>  
    </table>
    <ui>Ответ HTTP состоит из следующих элементов:
        <li>Версия протокола HTTP.</li>
        <li>Код состояния, указывающий, был ли запрос успешным или нет.</li>
        <li>Сообщение о состоянии, представляющее собой краткое описание кода состояния.</li>
        <li>Заголовок, предоставляющий клиенту дополнительную информацию.</li>
        <li>Тело (необязательно), содержащее ресурсы, отправленные сервером</li>
    </ui>
    <p>Вот упрощенный пример одного HTTP-ответа, с помощью которого сервер
        отправит клиенту информацию о книге:</p>
        <table>
            <thead>
                <tr>
                  <th>Version: HTTP/1.1</th>
                  <th>Status code: 200</th>
                  <th>Status message: OK</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                  <td>Headers:</td>
                </tr>
                <tr>
                    <td>Content-Type: application/json</td>
                </tr>
                <tr>
                    <td>Server: Apache</td>
                </tr>
                <tr>
                    <td>Accept-Encoding: gzip</td>
                </tr>
                <tr>
                    <td>Body:
                        {
                        “name”: “Alice’s Adventures in Wonderland”,
                        “author”:”Lewis Carroll”
                        }</td>
                </tr>
            </tbody>  
        </table>
    <h3>Методы HTTP</h3>
    <ul>Методы HTTP используются в HTTP-запросах для определения того, какие операции
        будут выполняться с ресурсом. HTTP определяет следующие операции:
        <li>GET используется для получения представления запрошенного
            ресурса. Не рекомендуется использовать GET для действий, которые могут изменить
            состояние ресурса.</li>
        <li>HEAD получит тот же ответ, что и GET, но без тела.</li>
        <li>POST используется для отправки объекта указанного ресурса, который изменит
            состояние ресурса. В основном он используется для создания новых ресурсов или обновления
            существующих ресурсов.</li>
        <li>PUT заменит текущее представление ресурса на представление из
            запроса. Мы должны использовать его, когда хотим обновить ресурс.</li>
        <li>DELETE, очевидно, удалит указанное представление ресурса.</li>
        <li>CONNECT установит туннель к серверу, указанному целевым
            ресурсом.</li>
        <li>ОПЦИИ будут описывать варианты связи для целевого ресурса.</li>
        <li>TRACE выполнит проверку обратной связи сообщения на пути к
            ресурсу.</li>
        <li>PATCH выполнит частичную модификацию ресурса. Может использоваться
            , когда необходимо обновить только часть ресурса, например, когда
            мы хотим обновить только пароль ресурса, который представляет
            учетную запись пользователя на веб-платформе.</li>
    </ul>
    <h3>Коды состояния HTTP</h3>
    <ul>Коды состояния используются в ответах HTTP, чтобы указать, был ли запрос
        успешным или нет. Как правило, мы можем разделить коды состояния на пять
        категорий, определенных стандартом:
        <li>1xx Информационные ответы: Сервер информирует клиента о том, что запрос
            был получен с некоторым предварительным сообщением,
            продолжая при этом обрабатывать запрос. Например, клиент должен отправить
            запрос с большим телом сообщения, чтобы в первом сообщении
            были отправлены только необходимые заголовки. Если первое сообщение было действительным, сервер
            сообщит клиенту, что он может отправить следующее сообщение с телом. Итак,
            мы отправим большой объем данных через сеть только в том случае, если все
            Предварительные условия выполнены, и сеть не будет перегружена.</li>
        <li>2xx Успешно: запрос успешно получен и обработан.
            Некоторые из наиболее распространенных успешных кодов (с соответствующими
            сообщениями о состоянии HTTP):
            <ul>
                <li>200 OK: запрос выполнен успешно.
                <li>204 Not Content: запрос выполнен успешно, но ответа
                    не будет .
            </ul>
        <li>Перенаправление 3xx: для успешного завершения запроса необходимо выполнить дополнительные действия (клиент должен использовать другой URL, сменить прокси и т. д.).</li>
        <li>Ошибки клиента 4xx: запрос содержит неверный синтаксис или не может быть обработан. Некоторые из наиболее распространенных успешных кодов (с соответствующими сообщениями о состоянии HTTP):
        <ul>
            <li>400 Bad Request: Сервер не может обработать запрос из-за
                недействительного запроса (необходимое поле отсутствует в теле, какое-то поле
                содержит запрещенное или недопустимое значение и т. д.).</li>
            <li>401 Несанкционировано: клиент должен выполнить аутентификацию перед
                выполнением определенных операций, иначе будут предоставлены неверные учетные данные.</li>
            <li>403 Запрещено: у клиента нет разрешения на доступ к определенным
                ресурсам или выполнение определенных операций.</li>
            <li>404 Not Found: запрошенный ресурс не найден сервером
                .</li>
        </ul>
        </li>
        <li>Ошибки сервера 5xx: серверу не удалось обработать действительный запрос:
            <ul>
                <li>500 Внутренняя ошибка сервера: наиболее распространенная ошибка сервера. На сервере
                    возникла ситуация, которую он не может разрешить (сервер
                    потеряно соединение с базой данных, невозможно связаться с другими сервисами и так
                    далее).</li>
            </ul>
        </li>
    </ul>
<h3>Дополнительные функции</h3>
    <ul>Мы можем использовать HTTP для управления некоторыми общими функциями, связанными со
        связью клиент-сервер. Вот некоторые из функций:
        <li><b>Кэширование:</b> мы можем использовать HTTP для управления тем, что будет кэшироваться и
            как долго. Кроме того, мы можем явно указать поставщикам кэша игнорировать
            сохраненные данные.</li>
        <li><b>Ограничение происхождения:</b> веб-браузеры обеспечивают строгое разделение между
            веб-сайтами. Только страницы одного и того же источника могут получить доступ ко всей информации
            на веб-странице. Мы можем использовать HTTP, чтобы ослабить это строгое разделение на
            стороне сервера, чтобы другие домены могли получить доступ к ресурсам.</li>
        <li><b>Аутентификация:</b> некоторые ресурсы могут быть защищены, поэтому
            доступ к ним могут получить только пользователи с определенными привилегиями. Базовая аутентификация может быть
            предоставляется HTTP либо через заголовки, связанные с аутентификацией, либо путем
            установления определенного сеанса с использованием файлов cookie.</li>
        <li><b>Сеансы:</b> с помощью файлов cookie HTTP мы можем создать сеанс, чтобы обмениваться
            контекстом посредством нескольких запросов. Это часто используется в
            приложениях электронной коммерции, где содержимое корзины покупок должно
            запоминаться посредством нескольких разных запросов.</li>
    </ul>
    <h3>HTTP и REST</h3>
    <p>REST и HTTP — это не одно и то же! REST представляет собой архитектурный стиль программного обеспечения
        , используемый для проектирования системы, в которой клиент и сервер
        будут обмениваться представлениями ресурсов, а HTTP представляет собой
        фактический протокол, который выполняет этот обмен. HTTP — наиболее широко используемый
        протокол в службах RESTful, но он не является обязательным для REST,
        вместо него мы можем использовать другие протоколы.</p>
        <p>Методы REST часто (ошибочно) связаны с методами HTTP. Никаких
        рекомендаций о том, какие HTTP-методы следует использовать для
        метода ресурса, нет, единственное правило — мы создаем единый интерфейс.</p>
        <p>Если мы решим, что метод POST создаст новый ресурс, нам следует использовать
        POST для создания всех ресурсов в нашей системе. В остальном
        никаких дополнительных правил нет. Если нас это устраивает, мы можем использовать POST для всех операций.</p>

    <h2>JSON</h2>
    <p>JSON (нотация объектов JavaScript) можно описать как текстовый формат, который
        можно использовать для хранения и транспортировки данных. Он указан Дугласом
        Крокфордом и экспортирован из JavaScript.</p>
    <p>Одним из основных преимуществ формата JSON является простота понимания
        . Когда мы видим текст в формате JSON, нам сразу понятно,
        какой объект представляет этот текст (пример мы увидим позже).</p>
    <p>Кроме того, JSON не зависит от языка, хотя изначально он был разработан для
        JavaScript, его поддерживают все популярные языки программирования (Go не является
        исключением). Поддержка JSON логична, если учесть, что это всего лишь специальный текстовый
        формат, а большинство языков программирования умеют обрабатывать текст.</p>

    <ui>Синтаксис JSON имеет несколько простых правил:
        <li>Данные представляются в виде пары имя-значение. Имя должно быть строкой,
            а значение должно быть одного из следующих типов: строка, число
            (целое или с плавающей запятой), объект (должен соответствовать синтаксису JSON), логическое значение, массив (любого
            типа, поддерживаемого JSON) или значение NULL. Строка должна быть заключена в
            двойные кавычки.</li>
        <li>Данные разделяются запятой.</li>
        <li>Фигурные скобки содержат объект.</li>
        <li>Квадратные скобки содержат массив.</li>
    </ui>
    <p>Интересно, что для дат нет типа. Мы должны обрабатывать их как строки.</p>
    <p>Поскольку это всего лишь текст, JSON легко отправлять с клиента на сервер и наоборот
        . Чтобы отправить его через HTTP, мы должны поместить его в тело и установить заголовок ContentType: application/json.</p>
    <p>В следующем примере показано представление человека в
        формате JSON. Данные о супруге указаны как объект, а имена детей —
        в массиве:</p>
    <pre><code>{
        “name”: “John Smith”,
        “age”: 33,
        “married”: true,
        “spouse”: {
            “name”: “Julie”,
            “age”: 30
        },
        “children”: [
            “Jack”,
            “Jill”
        ]
        }</code></pre>
    <p>Теперь, когда мы знакомы с форматом JSON, мы можем увидеть, как он поддерживается
        языком программирования Go.</p>
    
    <h3>JSON и язык программирования Go</h3>
    <p>Go поддерживают JSON стандартной библиотекой через
            пакет кодирования/json. Этот пакет реализует кодирование и
            декодирование JSON.</p>
    <p>Декодирование — это процесс, в котором данные JSON преобразуются и сохраняются в
            структуру Go. Декодирование будет выполняться путем вызова
            функции Unmarshal():
            err := json.Unmarshal(b, &s)</p>
    <p>Функция будет принимать два параметра: данные JSON ([]byte) и указатель на структуру
        . Если срез байтов содержит действительный JSON, данные из него будут сохранены в
        структуре, а ошибка будет равна нулю. В противном случае будет возвращена ошибка и
        частично декодированные данные будут сохранены в структуре.</p>
    <p>Следующие структуры представляют JSON из предыдущего примера:</p>
    <pre><code>
        type spouse struct {
            Name string
            Age int
        }

        type person struct {
            Name string
            Age int
            Married bool
            Spouse spouse
            Children []string
        }</code></pre>

    <p>Функция Unmarshal() успешно декодирует JSON и сопоставляет
        данные JSON с полями структуры, только если имена полей структуры начинаются с Заглавная буква.
        Будут декодированы только поля, которые можно найти в типе назначения. Если наш
        JSON содержит, например, «pet»:»dog», эта информация будет потеряна
        во время декодирования.</p>
    <p>Если мы предположим, что переменная jsonString содержит строковое представление JSON
        из нашего примера, следующий код выполнит декодирование:
    </p>
    <pre><code>
        var p person

        err := json.Unmarshal([]byte(jsonString), &p)
        if err != nil {
            fmt.Println(“Failed to decode JSON”)
        }</code></pre>
    <p>Обычно мы выполняем декодирование на стороне сервера, чтобы извлечь данные из запроса,
        отправленного нас на стороне клиента.
        В отличие от декодирования, кодирование — это процесс, в котором данные, хранящиеся в
        структуре Go, преобразуются в JSON. Кодирование можно выполнить с помощью Marshal():</p>
        <pre><code>
            err, b := json.Marshal(&s)
        </code></pre>
    <p>Функция принимает исходную структуру. Если кодирование может быть выполнено,
        будет возвращен срез байтов, содержащий JSON, а err будет иметь значение nil,
        в противном случае будет возвращена ошибка. Ошибка может возникнуть в двух случаях:
        указан неподдерживаемый тип (канальный, комплексный и т. д.) или когда
        указаны недопустимые значения.</p>
    <p>Следующий код закодирует переменную типа person в JSON:</p>
    <pre><code>
        jsonByte, err := json.Marshal(p)
        if err != nil {
            fmt.Println(“Failed to encode JSON”)
        }</code></pre>
    <p>Кодирование будет выполняться на стороне сервера для подготовки данных для
        ответа, который будет отправлен на клиентскую сторону.</p>

    <h2>Маршрутизация</h2>
    <p>Маршрутизация может быть описана как процесс, в котором будет определено, кто получит
        конкретный запрос. Получатель запроса обычно называется обработчиком
        и может быть определен как функция, которая будет получать и обрабатывать
        запросы.</p>
    <ul>Запросы маршрутизируются на основе двух параметров:
        <li>Метод HTTP.</li>
        <li>Путь запроса.</li>
    </ul>
    <p>Комбинация этих двух параметров и обработчика называется маршрутом. Маршруты
        обычно создаются и добавляются на веб-сервер до того, как сервер запустится
        и начнет прослушивать запросы. Язык программирования Go предоставляет пару пакетов, которые можно использовать для маршрутизации; в следующих главах
        мы увидим, как их использовать .</p>
    <p>Иногда путь запроса в маршруте может содержать специальные символы, называемые
        подстановочными знаками, которые можно использовать для замены одного или нескольких символов. Подстановочные знаки обычно используются для маршрутизации группы путей к одному обработчику (например,для всех операций чтения будет использоваться один обработчик).</p>
    <ul>Широко используются два подстановочных знака:
        <li>Одна звездочка (*), которая может встречаться в любом месте пути и
            представляет один полный компонент пути.</li>
        <li>Двойная звездочка (**) или завершающий подстановочный знак должны находиться в конце пути
            и обозначают любую оставшуюся часть пути.</li>
    </ul>
    <ul>Следующие пути:
        <li>/person/test/id</li>
        <li>/person/prod/id</li>
    </ul>
    <p>Могут быть сгруппированы одной звездочкой:</p>
    <p>/person/*/id</p>
    <p>Или с завершающим подстановочным знаком:</p>
    <p>/person/**</p>
    <p>А по следующему пути мы можем направить все запросы к одному обработчику:</p>
    <p>/**</p>    
    <p>Важно отметить, что некоторые реализации маршрутизатора поддерживают
        подстановочные знаки, а некоторые нет. Мы также можем использовать их в
        документации API.</p>
<h2>Заключение</h2>
<p>Теперь мы знакомы со всеми основами, связанными с серверами и серверными
    приложениями. Мы знаем, как разработать наше решение и какие протоколы и
    форматы данных широко используются. Благодаря знаниям, собранным в этой и
    предыдущих главах, мы готовы начать разработку нашего веб-серверного
    приложения.</p>
    <p>В следующей главе мы, наконец, установим язык программирования Go на
        наш локальный компьютер и настроим IDE (интегрированную среду разработки).
        После этого мы приступим к разработке и обучению использованию стандартных и
        сторонних библиотек.</p>
<h2>Что следует помнить</h2>
<ul>
    <li>На практике веб-серверы представляют собой комбинацию различных серверов,
        каждый из которых выполняет определенную задачу.</li>
    <li>Клиент инициирует связь и выбирает, какая операция будет
        выполнена с ресурсом.</li>
    <li>Клиент может использовать несколько серверов, а серверы могут обслуживать несколько
        клиентов.</li>
    <li>REST и HTTP — это не одно и то же. REST — это архитектурный стиль,
        а HTTP — это протокол обмена ресурсами, часто используемый в приложениях
        , разработанных в соответствии с рекомендациями REST.</li>
    <li>Формат JSON прост для понимания; когда мы видим текст в
        формате JSON, становится ясно, какой объект представляет этот текст.</li>
</ul>













</body>
</html>