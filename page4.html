<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Page 4</title>
    <link href="static/css/main.css" rel="stylesheet">
</head>
    <body>
        <h1>Глава 4. Настройка проекта с использованием
            языка программирования Go</h1>
        <h2>Введение</h2>
        <p>В этой главе мы выполним всю подготовку к разработке приложения. Сначала
            мы установим Go и настроим интегрированную среду разработки (IDE).
            После этого мы напишем нашу первую небольшую программу и научимся ее собирать и запускать.
            В конце главы мы узнаем, как использовать стандартные и сторонние
            библиотеки, а также получим дополнительную информацию о некоторых библиотеках, которые мы будем использовать.</p>
        <h2>Стандартная библиотека</h2>
        <p>В качестве расширения стандартных функций языка Go поставляется с набором основных
            пакетов, расширяющих функциональность языка. Эти пакеты являются частью
            стандартной библиотеки. С помощью стандартной библиотеки мы можем выполнять множество обычных задач, таких как
            вывод стандартного вывода или выполнение простых математических операций, без
            необходимости писать собственную реализацию или загружать пакеты, опубликованные
            другими разработчиками.</p>
        <ul>Поскольку стандартная библиотека ограничена языком, она имеет несколько специальных гарантий:
            <li>Он всегда будет существовать со всеми пакетами для каждой второстепенной версии языка программирования Go.</li>
            <li>Все пакеты будут следовать правилу обратной совместимости (новейшая
                версия будет поддерживать константы и методы из предыдущих версий).</li>
            <li>Стандартная библиотека является частью процесса разработки, сборки и выпуска
                языка программирования Go.</li>
            <li>Участники Go будут поддерживать и проверять стандартную библиотеку.</li>
            <li>Все пакеты из стандартной библиотеки будут тестироваться и тестироваться с
                каждой новой версией языка программирования Go.</li>
        </ul>
        <ul>Следующие пакеты (и подпакеты) являются частью стандартной библиотеки (этот список можно использовать как напоминание о том, что можно найти в конкретном пакете):
            <li>archive(архив): Поддержка архивов (несколько файлов и папок, сжатых в один файл):
                <ul>
                    <li>tar: методы чтения и записи .tar-архивов.</li>
                    <li>zip: методы чтения и записи ZIP-архивов.</li>
                </ul>
            </li>
            <li>bufio: реализация буферизованного ввода-вывода.</li>
            <li>builtin: документация по предварительно объявленным идентификаторам (языковые константы и встроенные методы).</li>
            <li>bytes: набор функций для манипуляций с байтовыми фрагментами.</li>
            <li>compress: Коллекция различных алгоритмов сжатия:
                <ul>
                    <li>bzip2: реализация распаковки bzip2.</li>
                    <li>flate: реализация формата данных сжатия DEFLATE.</li>
                    <li>gzip: методы чтения и записи файлов, сжатых в
                        формате gzip.</li>
                    <li>lzw: реализация формата данных сжатия Лемпеля-Зива-Велча.</li>
                    <li>zlib: методы чтения и записи файлов, сжатых в
                        формате zlib.</li>
                </ul>
            </li>
            <li>container:  сложные структуры данных, которые используются для хранения коллекций данных:
            <ul>
                <li>heap: методы для операций с кучей. Куча может быть определена как дерево,где каждый узел является узлом с минимальным значением в своем поддереве.</li>
                <li>list: методы для операций с двусвязным списком. Двойной связный список можно
                    определить как набор последовательно связанных узлов, где каждый узел содержит данные, указатель на предыдущий элемент и указатель на следующий элемент.</li>
                <li>ring: методы для операций с циклическим списком. Циклический список — это разновидность двусвязного списка, в котором последний элемент указывает на первый и наоборот.</li>
                
            </ul></li>
            <li>context: тип контекста определен в этом пакете. Контекст может переносить сроки, сигналы отмены и другие подобные значения в области запроса через границы API и между процессами.</li>
            <li>crypto: набор общих криптографических констант и методов:
                <ul>
                    <li>aes: реализация шифрования AES.</li>
                    <li>cipher(шифр): реализация стандартных режимов блочного шифрования <a href="https://csrc.nist.gov/projects/block-cipher-techniques/bcm/current-modes">(список текущих режимов можно найти здесь) </a></li>
                    <li>Des: Реализация стандарта шифрования данных (DES) и
                        алгоритма тройного шифрования данных (TDEA).</li>
                    <li>dsa: реализация алгоритма цифровой подписи (DSA).</li>
                    <li>ecdh: реализация обмена ключами Диффи-Хеллмана с эллиптической кривой (ECDH) по кривым NIST и Curve25519.</li>
                    <li>ecdsa: реализация алгоритма цифровой подписи на основе эллиптических кривых (ECDSA).</li>
                    <li>ed25519: реализация алгоритма подписи ED25519.</li>
                    <li>elliptic: реализация стандартных эллиптических кривых NIST P-224, P-256, P-384 и P-521 над простыми полями.
                    Если возможно, следует использовать более безопасные и эффективные пакеты crypto/ecdh.</li>
                    <li>hmac: реализация кода аутентификации сообщений с использованием хэш-ключа (HMAC).</li>
                    <li>md5: реализация алгоритма хеширования MD5.</li>
                    <li>rand: Криптографически безопасный генератор случайных чисел.</li>
                    <li>rc4: реализация шифрования RC4.</li>
                    <li>rsa: реализация шифрования Ривеста-Шамира-Адлемана (RSA).</li>
                    <li>sha1: реализация SHA1 (SHA означает алгоритм безопасного хеширования).</li>
                    <li>sha256: реализация SHA224 и SHA256.</li>
                    <li>sha512: реализация SHA-384, SHA-512/224 и SHA512/256.</li>
                    <li>subtle: набор функций, которые часто используются в коде, связанном с криптографией, но требуют осторожного (тонкого) использования для их правильного использования.</li>
                    <li>tls: частичная реализация TLS 1.2 и TLS 1.3 (TLS означает
                        безопасность транспортного уровня).</li>
                    <li>x509: методы и функции для анализа ключей и
                        сертификатов, закодированных в формате X.509.</li>
                </ul>
            </li>
            <li>database: Интерфейс для работы с базами данных:
                <ul>
                    <li>sql: Интерфейс для SQL и SQL-подобных баз данных.</li>
                </ul>
            </li>
            <li>debug: набор инструментов, которые можно использовать для отладки: <ul>
                <li>buildinfo: предоставляет доступ к информации о сборке, встроенной в двоичный файл Go.</li>
                <li>dwarf: обеспечивает доступ к отладочной информации DWARF, загружаемой из исполняемого файла.</li>
                <li>elf: обеспечивает доступ к объектным файлам ELF.</li>
                <li>gosym: обеспечивает доступ к символу Go и номеру строки. Эта
                    информация генерируется компилятором gc и внедряется в
                    двоичный файл Go.</li>
                <li>macho: обеспечивает доступ к объектным файлам Mach-O.</li>
                <li>pe: Обеспечивает доступ к переносимым исполняемым файлам Microsoft Windows.</li>
                <li>plan9obj: обеспечивает доступ к файлам Plan 9 a.out.</li>
            </ul></li>
            <li>embed: обеспечивает доступ к файлам, встроенным в работающую программу.</li>
            <li>encoding: предоставляет интерфейс, который можно использовать для преобразования данных из байтового представления в текстовое и наоборот: <ul>
                <li>ascii85: реализация кодирования данных ascii85, используемая в
                    документах Adobe PostScript и PDF.</li>
                <li>asn1: метод анализа структур данных ASN.1, закодированных в DER.</li>
                <li>base32: реализация кодировки base32.</li>
                <li>base64: реализация кодировки base64.</li>
                <li>binary: метод перевода между последовательностями чисел и байтов.</li>
                <li>csv: метод чтения и записи файлов со значениями, разделенными запятыми (CSV).</li>
                <li>gob: метод управления потоком комков. Gobs можно определить как
                    двоичные значения, которыми обмениваются кодировщик и декодер.</li>
                <li>hex: реализация шестнадцатеричного кодирования и декодирования.</li>
                <li>json: реализация кодирования и декодирования JSON.</li>
                <li>pem: реализация кодирования почты с улучшенной конфиденциальностью.</li>
                <li>xml: реализация парсера XML 1.0.</li>
            </ul></li>
            <li>errors: набор функций, которые можно использовать для обработки ошибок.</li>
            <li>expvar: стандартизированный интерфейс для доступа к общедоступным переменным. Примером общедоступной переменной является счетчик операций на серверах, который будет доступен через конечную точку HTTP.</li>
            <li>flag: реализация анализа флага командной строки.</li>
            <li>fmt: реализация форматированного ввода и вывода. В наших примерах мы используем функции из этого пакета для отображения значения в стандартном выводе.</li>
            <li>go: набор пакетов, специфичных для Go: <ul>
                <li>ast: объявление типов, используемых для представления абстрактных синтаксических деревьев (AST) для пакетов Go.</li>
                <li>build: функции и методы, которые можно использовать для сбора информации, связанной с пакетами Go.</li>
                <li>constant: реализация нетипизированных констант Go и связанных с ними операций.</li>
                <li>doc: Извлечение документации исходного кода из Go AST.</li>
                <li>format: реализация стандартного форматирования исходного кода Go.</li>
                <li>importer: предоставляет доступ к данным, предоставленным импортерами.</li>
                <li>parser: реализация парсера исходного файла Go.</li>
                <li>printer: Печать узлов AST.</li>
                <li>scanner: сканер для исходного кода Go.</li>
                <li>token: определение констант, представляющих лексические токены языка программирования Go и основные операции с токенами.</li>
                <li>types: объявление типов данных GO и реализация алгоритмов проверки типов.</li>
            </ul></li>
            <li>hash: Интерфейс для хеш-функций: <ul>
                <li>adler32: реализация контрольной суммы Adler-32.</li>
                <li>crc32: реализация 32-битной проверки циклическим избыточным кодом.</li>
                <li>crc64: реализация 64-битной проверки циклическим избыточным кодом.</li>
                <li>fnv: реализация некриптографического хэша FNV-1 и FNV-2.</li>
                <li>maphash: хэш-функции, которые можно выполнять с последовательностями байтов.</li>
            </ul></li>
            <li>html: набор функций, которые используются для экранирования и отмены экранирования HTML-
                текста. <ul>
                    <li>template: реализация управляемых данными шаблонов для создания
                        безопасного вывода кода HTML.</li>
                </ul></li>
            <li>image: Реализация базовых 2D-изображений: <ul>
                <li>color: Реализация основных цветов.</li>
                <li>draw: набор функций для базовой композиции изображений.</li>
                <li>gif: реализация декодера и кодировщика изображений GIF.</li>
                <li>jpeg: реализация декодера и кодировщика изображений JPEG.</li>
                <li>png: реализация декодера и кодировщика изображений PNG.</li>
            </ul></li>
            <li>index/suffixarray: индексированная подстрока для поиска данных с
                использованием памяти.</li>
            <li>io: Интерфейс для примитивов ввода-вывода: <ul>
                <li>fs: интерфейс к файловой системе.</li>
                <li>ioutil: служебные функции ввода-вывода (чтение файла, запись файла, чтение
                    каталога и т. д.).</li>
            </ul></li>
            <li>log: Реализация функций журналирования: <ul>
                <li>syslog: интерфейс к службе системного журнала.</li>
            </ul></li>
            <li>math: Математические константы и функции: <ul>
                <li>big: реализация арифметики произвольной точности (большие числа).</li>
                <li>bits: функция для манипуляций с целочисленными типами без знака.</li>
                <li>cmplx: Константы и функции для работы с комплексными числами.</li>
                <li>rand: реализация генератора псевдослучайных чисел. Этот
                    генератор не подходит для работы, чувствительной к безопасности, для этой цели
                    нам следует использовать генератор из пакета crypto/rand.</li>
            </ul></li>
            <li>mime: частичная реализация спецификации многоцелевых расширений почты Интернета
                (MIME): <ul>
                    <li>multipart: реализация многочастного анализа MIME.</li>
                    <li>quoteprintable: реализация кодировки quote-printable.</li>
                </ul></li>
            <li>net: интерфейс для сетевого ввода-вывода. Сетевой ввод-вывод включает
                протокол управления передачей (TCP), интернет-протокол (IP), протокол пользовательских данных
                (UDP), разрешение доменных имен, доменные сокеты Unix и т. д.: <ul>
                    <li>http: реализация HTTP-клиента и сервера. Позже мы рассмотрим этот
                        пакет более подробно.</li>
                    <li>mail: Реализация парсинга почтовых сообщений.</li>
                    <li>netip: Определение типа, представляющего IP-адрес.</li>
                    <li>rpc: обеспечивает доступ к экспортированным методам объекта по
                        сети или любому другому соединению ввода-вывода.</li>
                    <li>smtp: реализация простого протокола передачи почты.</li>
                    <li>textproto: обеспечивает поддержку текстовых
                        протоколов запросов-ответов.</li>
                    <li>url: реализация экранирования и анализа URL-запросов.</li>
                </ul></li>
            <li>os: независимый от платформы интерфейс к функциям операционной системы: <ul>
                <li>exec: выполнение внешних команд.</li>
                <li>signal: Обеспечивает доступ к входящим сигналам.</li>
                <li>user: обеспечивает поиск учетных записей пользователей по имени или идентификатору.</li>
            </ul></li>
            <li>path: реализация манипуляций с путями, разделенными косой чертой: <ul>
                <li>filepath: реализация манипуляций с путем к файлу, совместимая с
                    целевой операционной системой.</li>
            </ul></li>
            <li>plagin: реализация загрузки и разрешения символов пакетов Go.</li>
            <li>reflect: реализация отражения во время выполнения. Это позволит
                программе манипулировать объектами произвольных типов (например, определять
                фактический тип переменной интерфейса {}).</li>
            <li>regexp: реализация поиска по регулярным выражениям: <ul>
                <li>syntax: функции для синтаксического анализа регулярных выражений в деревья синтаксического анализа и
                    компиляции деревьев синтаксического анализа в программы.</li>
            </ul></li>
            <li>Runtime: набор операций для взаимодействия с системой времени выполнения Go
                Одним из примеров использования является управление горутинами. <ul>
                    <li>cgo: поддержка кода, созданного инструментом cgo.</li>
                    <li>debug: возможности программ для отладки во время работы</li>
                    <li>metrics: Интерфейс для доступа к метрикам, экспортируемым средой выполнения Go
                        (сборщик мусора, использование памяти и т. д.).</li>
                    <li>pprof: экспорт данных профилирования времени выполнения в формате, ожидаемом
                        инструментом визуализации pprof.</li>
                    <li>race: реализация логики обнаружения гонки данных.</li>
                    <li>trace: возможности программ для создания трассировок, которые могут использоваться
                        трассировщиком выполнения GO.</li>
                </ul>
            </li>
            <li>sort: методы сортировки срезов и коллекций.</li>
            <li>strconv: реализация преобразования базовых типов в
                строковое представление и обратно.</li>
            <li>strings: функции для манипулирования строками в кодировке UTF-8. Мы видели
                использование этого пакета в некоторых примерах.</li>
            <li>sync: реализация базовых примитивов синхронизации. Мы увидели
                примеры использования блокировок взаимного исключения (мьютексов). <ul>
                    <li>atomic: атомарные примитивы, полезные в алгоритмах синхронизации.</li>
                </ul></li>
            <li>syscall: интерфейс к примитивам операционной системы: <ul>
                <li>js: обеспечивает доступ к среде хоста WebAssembly.</li>
            </ul></li>
            <li>testing: Go поддерживает автоматическое тестирование. Мы увидим использование этого
                пакета в отдельной главе: <ul>
                    <li>fstest: Поддержка тестирования файловых систем.</li>
                    <li>iotest: реализация средств чтения и записи, предназначенных для использования в
                        тестах.</li>
                    <li>quick: инструменты для тестирования черного ящика.</li>
                </ul></li>
            <li>text: Методы манипулирования текстом: <ul>
                <li>scanner: реализация сканера и токенизатора для
                    текста в кодировке UTF-8.</li>
                <li>tabwriter: реализация фильтра, который преобразует столбцы с вкладками
                    в выровненный текст.</li>
                <li>template: реализация управляемых данными шаблонов для
                    генерации текстового вывода.</li>
            </ul></li>
            <li>time: Функции измерения и отображения времени: <ul>
                <li>tzdata: предоставляет копию базы данных часовых поясов.</li>
            </ul></li>
            <li>unicode: реализация функций для тестирования
                свойств кодовой точки Unicode: <ul>
                    <li>utf16: реализация кодирования и декодирования последовательностей UTF-16.</li>
                    <li>utf8: реализация кодирования и декодирования последовательностей UTF-8</li>
                </ul></li>
            <li>unsafe: операции, которые можно использовать для переопределения безопасности типов типов Go.</li>
            <li>internal: перейдите к внутренним инструментам. К некоторым инструментам можно получить доступ к
                конфигурациям сборки, обнаружению функций процессора, обнаружению условий гонки
                и т. д.</li>
        </ul>
    <p>Мы уже использовали некоторые пакеты из стандартной библиотеки (fmt, math,
        coding/json). Вот пример того, как мы можем использовать пакет журналов. Сначала
        мы должны импортировать пакет. После этого внутри функции div() мы будем использовать
        журнал для отображения входных параметров, результатов и потенциальной ошибки (деление на ноль):</p>
<pre><code>
    package main

    import (
    “log”
    )

    func div(a, b float32) (c float32) {
        log.Println(“Input parameters:”, a, b)
        if b == 0 {
            log.Println(“Division by zero”)
            return 0
        }
        c = a / b
        log.Println(“Division result:”, c)
        return
    }

    func main() {
        div(6.0, 3.0)
        div(6.0, 0.0)
    }</code></pre>

    <p>Каждая строка журнала будет содержать метку времени и указанное сообщение журнала. Код из этого
        примера зарегистрирует следующий вывод:</p>
    <p class="terminal">
        2022/09/14 07:44:44 Input parameters: 6 3
        2022/09/14 07:44:44 Division result: 2
        2022/09/14 07:44:44 Input parameters: 6 0
        2022/09/14 07:44:44 Division by zero</p>

<h2>Сторонние библиотеки</h2>
<p>Пакеты, разработанные, поддерживаемые и выпущенные лицом (разработчиком, компанией
    и т. д.), отличным от исходного поставщика (в нашем случае участниками Go), считаются
    сторонними библиотеками. Обычно они содержат некоторые специфические
    функции, которые широко не используются, поэтому их можно использовать повторно в различных
    ситуациях.</p>
<p>Вот пример недостающей функциональности языка программирования Go.
    Go включает в себя несколько типов данных, которые представляют собой какую-то коллекцию (массив,
    срез, карту и т. д.), но этот набор не входит в их число. Set — это тип данных, который может
    хранить уникальные значения (без дубликатов) без определенного порядка и может быть определен как
    реализация математической концепции конечного множества.</p>
<p>К счастью, кто-то разработал библиотеку, которую можно установить и использовать внутри наших
    программ на Go. Первым шагом является загрузка всех пакетов, включенных в библиотеку. Для этой задачи мы
    будем использовать команду go get. Следующая команда загрузит
    связанную библиотеку:</p>
<p class="terminal">go get github.com/deckarep/golang-set</p>
<p>
    Если все выполнено успешно, в консоли/терминале должен отобразиться вывод, подобный следующему (версия может быть другой):</p>
<pre><code>
    go: downloading github.com/deckarep/golang-set v1.8.0
    go: added github.com/deckarep/golang-set v1.8.0</code></pre>

<p>Теперь мы можем импортировать пакеты библиотеки так же, как пакеты из
    стандартной библиотеки и пакеты, которые мы создали. Мы будем использовать его для создания двух наборов:
    один из которых включает желтые фрукты, а другой — красные фрукты, и создадим
    объединение этих двух наборов. Набор можно создать двумя способами: создать пустой набор
    и добавлять элементы один за другим или преобразовать срез в набор:</p>
<pre><code>
    package main

import (
    “fmt”
    set “github.com/deckarep/golang-set”
)

func main() {
    yellowFruit := set.NewSet()
    yellowFruit.Add(“banana”)
    yellowFruit.Add(“lemon”)
    yellowFruit.Add(“pineapple”)
    fmt.Println(yellowFruit)
    redFruit := set.NewSetFromSlice(
        []interface{}{“apple”, “cherry”, “strawberry”})
    fmt.Println(redFruit)
    fruit := yellowFruit.Union(redFruit)
    fmt.Println(fruit)
}
</code></pre>
<p>Если мы выполним эту программу, на стандартном выводе будет отображен следующий вывод:</p>
<p class="terminal">
    Set{banana, lemon, pineapple}
    Set{apple, cherry, strawberry}
    Set{pineapple, apple, cherry, strawberry, banana, lemon}</p>

<p>Элементы внутри каждого набора могут отображаться в разном порядке, поскольку набор не гарантирует какого-либо определенного порядка.</p>
<p>Важно отметить, что нам следует проверять сторонние библиотеки перед
    их использованием. Мы должны проверить, регулярно ли обновляется и поддерживается библиотека, и
    предоставляется ли поддержка автором. Кроме того, если мы колеблемся между парой похожих библиотек, нам следует провести несколько тестов производительности и решить, какая из них лучше всего соответствует
    нашим требованиям.</p>
<p>С помощью команды поставщика мы можем иметь локальную копию всех пакетов, используемых для сборки
    и тестирования. Все файлы будут храниться в каталоге поставщика основного модуля, поэтому в
    случае, если подключение к Интернету недоступно или определенный пакет больше не будет доступен.
    доступны, мы можем без проблем разработать и запустить наше приложение.</p>
<p>Следующая команда скопирует пакеты в каталог поставщика:</p>
<p class="terminal">go mod vendor</p>
<p>Теперь, когда мы знаем, как создавать собственные пакеты, использовать пакеты из
    стандартной библиотеки и пакеты из сторонних библиотек, мы готовы к
    разработке нашего веб-серверного приложения.</p>

<h2>Пакет net/http</h2>
<p>Пакет net/http — это один из базовых пакетов для разработки веб-
    приложений. В предыдущих разделах мы видели, что этот пакет содержит реализацию
    HTTP-сервера и клиента. Теперь мы рассмотрим содержимое
    этого пакета более подробно.</p>
 <h3>Константы</h3>   
<p>Пакет net/http содержит константы для всех методов и статусов HTTP (
    некоторые из них мы видели в предыдущей главе):</p>
<pre><code>
    const (
MethodGet = “GET”
MethodHead = “HEAD”
MethodPost = “POST”
MethodPut = “PUT”
MethodPatch = “PATCH”
MethodDelete = “DELETE”
MethodConnect = “CONNECT”
MethodOptions = “OPTIONS”
MethodTrace = “TRACE”
)
const (
StatusContinue = 100
StatusSwitchingProtocols = 101
StatusProcessing = 102
StatusEarlyHints = 103
StatusOK = 200
StatusCreated = 201
StatusAccepted = 202
StatusNonAuthoritativeInfo = 203
StatusNoContent = 204
StatusResetContent = 205
StatusPartialContent = 206
StatusMultiStatus = 207
StatusAlreadyReported = 208
StatusIMUsed = 226
StatusMultipleChoices = 300
StatusMovedPermanently = 301
StatusFound = 302
StatusSeeOther = 303
StatusNotModified = 304
StatusUseProxy = 305
StatusTemporaryRedirect = 307
StatusPermanentRedirect = 308
StatusBadRequest = 400
StatusUnauthorized = 401
StatusPaymentRequired = 402
StatusForbidden = 403
StatusNotFound = 404
StatusMethodNotAllowed = 405
StatusNotAcceptable = 406
StatusProxyAuthRequired = 407
StatusRequestTimeout = 408
StatusConflict = 409
StatusGone = 410
StatusLengthRequired = 411
StatusPreconditionFailed = 412
StatusRequestEntityTooLarge = 413
StatusRequestURITooLong = 414
StatusUnsupportedMediaType = 415
StatusRequestedRangeNotSatisfiable = 416
StatusExpectationFailed = 417
StatusTeapot = 418
StatusMisdirectedRequest = 421
StatusUnprocessableEntity = 422
StatusLocked = 423
StatusFailedDependency = 424
StatusTooEarly = 425
StatusUpgradeRequired = 426
StatusPreconditionRequired = 428
StatusTooManyRequests = 429
StatusRequestHeaderFieldsTooLarge = 431
StatusUnavailableForLegalReasons = 451
StatusInternalServerError = 500
StatusNotImplemented = 501
StatusBadGateway = 502
StatusServiceUnavailable = 503
StatusGatewayTimeout = 504
StatusHTTPVersionNotSupported = 505
StatusVariantAlsoNegotiates = 506
StatusInsufficientStorage = 507
StatusLoopDetected = 508
StatusNotExtended = 510
StatusNetworkAuthenticationRequired = 511
)
</code></pre>
<ul>Кроме того, у нас есть несколько констант, связанных с конфигурацией:
    <li>DefaultMaxHeaderBytes: определение максимально разрешенного размера заголовков в HTTP-запросе. Постоянное значение установлено в 1 МБ, но его можно
        переопределить с помощью настройки Serve.MaxHeaderBytes. Тип сервера будет
        описан позже.</li>
    <li>DefaultMaxIdleConnsPerHost: определение значения по умолчанию для поля
        MaxIdleConnsPerHost из типа транспорта (этот тип также будет
        описан позже).</li>
    <li>TimeFormat: формат времени, который будет использоваться для времени в заголовках HTTP.</li>
</ul>
<h3>Переменные</h3>
<ul>Следующие переменные являются частью пакета net/http:
    <li>Ошибки, используемые HTTP-сервером. Ошибки достаточно описательны, поэтому просто перечислим их здесь:
        <pre><code>
            var (
                ErrBodyNotAllowed = errors.New(“http: request method or
                response status code does not allow body”)
                ErrHijacked = errors.New(“http: connection has been
                hijacked”)
                ErrContentLength = errors.New(“http: wrote more than the
                declared Content-Length”)
                // Deprecated
                ErrWriteAfterFlush = errors.New(“unused”)
            )
            var (
                ErrNotSupported = &ProtocolError{“feature not supported”}
                // Deprecated
                ErrUnexpectedTrailer = &ProtocolError{“trailer header without
                chunked transfer encoding”}
                ErrMissingBoundary = &ProtocolError{“no multipart boundary
                param in Content-Type”}
                ErrNotMultipart = &ProtocolError{“request Content-Type isn’t
                multipart/form-data”}
                // Deprecated
                ErrHeaderTooLong = &ProtocolError{“header too long”}
                // Deprecated
                ErrShortBody = &ProtocolError{“entity body too short”}
                // Deprecated
                ErrMissingContentLength = &ProtocolError{“missing
                ContentLength in HEAD response”}
            )</code></pre>
    </li>
    <li>Клиент по умолчанию и ServerMux по умолчанию:
        <pre><code>
            var (
                DefaultClient = &Client{}
                DefaultServeMux = &defaultServeMux
            )
        </code></pre>
    </li>
    <li>Распространенные ошибки:
        <pre><code>
            var (
                ErrAbortHandler = errors.New(“net/http: abort Handler”)
                ErrBodyReadAfterClose = errors.New(“http: invalid Read on
                closed Body”)
                ErrHandlerTimeout = errors.New(“http: Handler timeout”)
                ErrLineTooLong = internal.ErrLineTooLong
                ErrMissingFile = errors.New(“http: no such file”)
                ErrNoCookie = errors.New(“http: named cookie not present”)
                ErrNoLocation = errors.New(“http: no Location header in
                response”)
                ErrServerClosed = errors.New(“http: Server closed”)
                ErrSkipAltProtocol = errors.New(“net/http: skip alternate
                protocol”)
                ErrUseLastResponse = errors.New(“net/http: use last
                response”)
            )
        </code></pre>
    </li>
    <li>NoBody: io.ReadCloser без тела:
        <pre><code>
            var NoBody = noBody{}
        </code></pre>
    </li>
</ul>
<h3>Функции</h3>
<ul>Следующие функции являются частью пакета net/http, для каждой из них мы
    увидим объявление и небольшое описание:
    <li>func CanonicalHeaderKey(s string) строка: эта функция вернет
        канонический формат ключей заголовка. В каноническом формате первая буква и
        все буквы после дефиса (-) имеют верхний регистр, а все остальные буквы —
        строчные. Например, каноническим форматом кодирования контента является
        Content-Encoding.</li>
    <li>func DetectContentType(data []byte) строка: эта функция определяет
        тип контента для предоставленных данных. Будут
        проверены только первые 512 байт.</li>
    <li>func Error(w ResponseWriter, строка ошибки, код int): мы будем использовать эту функцию, когда для запроса необходимо ответить на конкретное сообщение об ошибке и HTTP-код .</li>
    <li>func Handle(строка шаблона, обработчик обработчика): функция, которая
        регистрирует обработчик в DefaultServeMux для данного шаблона.</li>
    <li>func HandleFunc (строка шаблона, обработчик func (ResponseWriter,
        *Request): функция, которая регистрирует функцию обработчика в
        DefaultServeMux для данного шаблона.</li>
    <li>Ошибка func ListenAndServe (строка адреса, обработчик обработчика): эта
        функция будет прослушивать сетевой адрес TCP (адрес) и обрабатывать входящие запросы, вызывая функцию Serve() с обработчиком.</li>
    <li>Ошибка func ListenAndServeTLS (строка адреса, certFile, строка keyFile,
        обработчик обработчика): аналогична функции ListenAndServe(), с
        несколькими отличиями. Эта функция ожидает соединения HTTPS и
        файлы с сертификатом и закрытым ключом.</li>
    <li>func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64)
        io.ReadCloser: Целью этой функции является ограничение размера тел
        для входящих запросов. Клиент может отправлять большие запросы (случайно или намеренно посредством вредоносных запросов), что может привести к пустой трате ресурсов сервера.</li>
    <li>func NotFound(w ResponseWriter, r *Request): мы будем использовать эту
        функцию для ответа на запросы с ответом 404 Not Found.</li>
    <li>func ParseHTTPVersion(vers string) (основной, младший int, ok bool):
        эта функция будет анализировать строку, представляющую версию HTTP (vers). Если
        мы попытаемся проанализировать строку версии HTTP/2.0, функция вернет следующие
        результаты: Major = 2, Minor = 0, ok = true.</li>
    <li>func ParseTime(текстовая строка) (t time.Time, ошибка): Функция для
        анализа заголовка времени. Поддерживаются все форматы, разрешенные HTTP/1.1.</li>
    <li>func ProxyFromEnvironment(req *Request) (*url.URL, ошибка): эта
        функция вернет URL-адрес прокси. URL-адрес прокси-сервера будет указан переменными
        среды HTTP_PROXY, HTTPS_PROXY и NO_PROXY.</li>
    <li>func ProxyURL(fixedURL *url.URL) func (*Request)(*url.URL,
        error): Эта функция вернет прокси-функцию, которая всегда будет возвращать
        один и тот же URL-адрес.</li>
    <li>func Redirect(w ResponseWriter, r *Request, строка URL, код
        int): мы будем использовать эту функцию для ответа на запросы с перенаправлением на
        URL-адрес. Предоставленный код должен быть из группы 3xx.</li>
    <li>Ошибка func Serve(l net.Listener, handler Handler): эта функция
        будет принимать входящие HTTP-соединения на предоставленном прослушивателе.
        Для каждого соединения будет создана новая горутина, которая читает запрос и вызывает соответствующий заголовок
        .</li>
    <li>func ServeContent(w ResponseWriter, r *Request, строка имени,
        modtime time.Time, content io.ReadSeeker): мы будем использовать эту функцию
        для ответа на запросы с содержимым, предоставленным в ReadSeeker. Если ContentType не установлен, функция попытается обнаружить тип по расширению
        имени файла или путем вызова функции DetectContentType().</li>
    <li>func ServeFile(w ResponseWriter, r *Request, строка имени): мы
        будем использовать эту функцию для ответа на запросы с содержимым из файла имени
        или каталога. Имя должно быть очищено перед вызовом функции.</li>
    <li>Ошибка func ServeTLS(l net.Listener, обработчик Handler, certFile,
        строка keyFile): функция аналогична функции Serve(). В отличие от функции Serve(), ServeTLS() ожидает соединения HTTPS, и мы должны
        предоставить файлы с сертификатом и закрытым ключом.</li>
    <li>func SetCookie(w ResponseWriter, cookie *Cookie): эта функция
        добавит заголовок Set-Cookie. Имя файла cookie должно быть действительным, а недействительные
        файлы cookie будут удалены.</li>
    <li>func StatusText(code int) string: простая функция, которая возвращает
        текстовое сообщение для предоставленного кода состояния. Например, для кода состояния 404
        функция вернет «Не найдено».</li>
</ul>

<h3>Типы</h3>
<ul>Следующие типы являются частью пакета net/http:
    <li>Client: HTTP-клиент, безопасный для одновременного использования. Значение по умолчанию (нулевое)
        для клиента — DefaultClient, то есть клиент, использующий
        DefaultTransport. Транспорт представляет собой механизм, с помощью которого
        выполняются отдельные HTTP-запросы. Транспорт имеет внутреннее состояние, поэтому
        клиент следует использовать повторно, а не создавать его при необходимости.</li>
    <li>CloseNotifier: интерфейс, используемый для обнаружения разрыва базового соединения . Этот тип устарел, и вместо него следует
        использовать Request.Context, но мы упомянем его здесь по историческим причинам.</li>
    <li>ConnState: состояние подключения клиента к серверу.</li>
    <li>Cookie: файл cookie HTTP (заголовок Set-Cookie в ответе HTTP и
        заголовок Cookie в HTTP-запросе).</li>
    <li>CookieJar: интерфейс для управления хранением и использованием запросов файлов cookie.</li>
    <li>Dir: Реализация файловой системы (будет использоваться собственная файловая система).</li>
    <li>FileSystem: интерфейс для доступа к коллекции файлов. Путь к файлу
        должен быть разделен косой чертой (/) независимо от того, какая операционная система хоста будет использоваться.</li>
    <li>File: тип, который будет возвращен методом Open() из
        FileSystem.</li>
    <li>Flusher: интерфейс для сброса буферизованных данных клиенту.</li>
    <li>Handler: интерфейс для ответа на HTTP-запросы. Содержит один единственный
        метод ServeHTTP(ResponseWriter, *Requests), который должен записывать
        заголовки ответов и данные в ResponseWriter и возвращать результат. Мы должны только
        читать запросы и никогда не изменять их.</li>
    <li>Header: карта, где ключ представляет имя заголовка, а значение
        представляет значение заголовка.</li>
    <li>Hijacker: интерфейс, реализованный ResponseWriters. Это позволяет обработчику HTTP
        взять на себя управление соединением.</li>
    <li>MaxBytesError: тип, который будет возвращен
        функцией MaxBytesReader() при превышении предела чтения.</li>
    <li>Pusher: интерфейс, реализованный ResponseWriter, поддерживает
        отправку данных с сервера HTTP/2.</li>
    <li>PushOptions: параметры метода Push() из Pusher. Опции состоят из
        метода (который представляет метод HTTP) и заголовка (который представляет
        заголовок HTTP).</li>
    <li>Request: представление HTTP-запроса. HTTP-запросы отправляются клиентом
        и принимаются сервером.</li>
    <li>ResponseController: тип, используемый обработчиком HTTP для управления ответом.
        Предоставляет дополнительные функции для каждого запроса, не обрабатываемые
        интерфейсом ResponseWriter.</li>
    <li>ResponseWriter: интерфейс, используемый обработчиком HTTP для создания
        ответа HTTP.</li>
    <li>RoundTripper: интерфейс для выполнения одной HTTP-транзакции.
        Ответ будет возвращен на предоставленный запрос.</li>
    <li>SameSite: определяет атрибут cookie для предотвращения атак межсайтовой подделки
        . Этот файл cookie не будет отправляться вместе с межсайтовыми запросами.</li>
    <li>ServeMux: мультиплексор для HTTP-запросов. Входящий запрос будет
        сопоставлен со списком зарегистрированных шаблонов и будет
        вызван соответствующий обработчик.</li>
    <li>Сервер: Параметры для запуска HTTP-сервера. Допустимой конфигурацией является
        значение по умолчанию (нулевое) для сервера.</li>
    <li>Transport: реализация RoundTripper, которая поддерживает HTTP, HTTPS
        и HTTP-прокси и безопасна для одновременного использования несколькими горутинами.
        Соединение будет кэшировано для повторного использования в будущем. Ответы с
        кодами состояния из группы 1xx будут автоматически обработаны или проигнорированы.</li>
</ul>
<h3>Простой HTTP-сервер</h3>
<p>В конце этой главы мы создадим один простой HTTP-сервер с
    пакетом net/http. Внутри функции main() мы будем использовать функцию HandleFunc() для
    регистрации функции-обработчика helloWorld() в DefaultServeMux для шаблона /hello. Функция helloWorld() — это простая функция, которая в ответ записывает строку
    Hello World и символ new.</p>
<p>В конце функции main() мы вызовем ListenAndServe(), чтобы начать
    прослушивание входящего запроса. Мы просто передадим номер порта в качестве
    адреса, поскольку приложение будет выполняться локально на нашей машине. Кроме того, мы
    будем использовать DefaultServeMux, поэтому передадим обработчику nil:</p>
<pre><code>
import (
    “fmt”
    “net/http”
)

func helloWorld(rw http.ResponseWriter, req *http.Request) {
    fmt.Fprintf(rw, “Hello World\n”)
}

func main() {
    http.HandleFunc(“/hello”, helloWorld)
    http.ListenAndServe(“:8080”, nil)
}
</code></pre>
<p>Чтобы протестировать наш небольшой HTTP-сервер, мы запустим его, откроем новую
    консоль/терминал и введем следующую команду:</p>
<p class="terminal">$ curl localhost:8080/hello</p>
<p>Строка Hello World должна отобразиться в терминале.</p>
<p class="terminal">
    Hello world
</p>
<h2>Заключение</h2>
<p>В этой главе мы узнали, как установить Go и настроить IDE. После этого мы
    создали наш первый проект и научились использовать стандартную и стороннюю библиотеку. В конце этой главы мы подробно рассмотрим
    пакет net/http из стандартной библиотеки Go и разработаем простое приложение, которое его использует.
    Теперь мы знакомы со всеми концепциями Go, связанными с
    разработкой приложений для веб-серверов. В следующей главе мы сосредоточимся больше на
    разработке приложений, после чего мы сможем приступить к фактической разработке нашего
    приложения веб-сервера.</p>
<h2>Ссылки</h2>
<p><a href="https://pkg.go.dev/std">https://pkg.go.dev/std</a></p>
<p><a href="https://github.com/deckarep/golang-set">https://github.com/deckarep/golang-set</a></p>

<h2>Что следует помнить</h2>
<ul>
    <li>Go поддерживается всеми современными операционными системами.</li>
    <li>Мы можем запустить код Go без создания исполняемого файла.</li>
    <li>Стандартная библиотека всегда будет существовать со всеми пакетами для каждой дополнительной версии языка программирования Go.</li>
    <li>Нам следует проверить, регулярно ли обновляется, поддерживается и поддерживается ли сторонняя библиотека автором.</li>
</ul>






    </body>
</html>
